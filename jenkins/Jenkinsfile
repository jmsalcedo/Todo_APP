pipeline {
    agent {
        docker {
            image 'python:3.12-slim'
            args '-u root'
        }
    }

    environment {
        PATH = "/root/.local/bin:${env.PATH}"
        // Nombre de la red temporal para este build
        TEST_NETWORK = "todo-net-${BUILD_NUMBER}"
        // El nombre del host debe ser el mismo que el del contenedor
        DB_HOST = "tododbtest-${BUILD_NUMBER}"
        DATABASE_URL = "postgresql://user:password@${DB_HOST}:5432/todo_db"
    }

    stages {
        stage('Setup Environment') {
            steps {
                script {
                    echo 'Configurando herramientas...'
                    sh 'apt-get update && apt-get install -y curl docker.io'
                    sh 'curl -LsSf https://astral.sh/uv/install.sh | sh'
                    
                    // Crear la red personalizada
                    sh "docker network create ${TEST_NETWORK}"
                    
                    // Conectar el contenedor actual (donde corre Jenkins Agent) a la nueva red
                    def containerId = sh(script: "hostname", returnStdout: true).trim()
                    sh "docker network connect ${TEST_NETWORK} ${containerId}"
                }
            }
        }

        stage('Install Dependencies') {
            steps {
                sh '/root/.local/bin/uv sync'
            }
        }

        stage('Run Integration Tests') {
            steps {
                script {
                    // Levantar Postgres en la misma red
                    docker.image('postgres:15-alpine').withRun(
                        "--network ${env.TEST_NETWORK} " + 
                        "--name ${env.DB_HOST} " +
                        "-e POSTGRES_USER=user " +
                        "-e POSTGRES_PASSWORD=password " +
                        "-e POSTGRES_DB=todo_db"
                    ) { c ->
                        echo 'Esperando a que la base de datos esté lista...'
                        sh 'sleep 20' 
                        
                        echo 'Ejecutando Pytest...'
                        // Usamos la DATABASE_URL que apunta al host dinámico
                        sh "DATABASE_URL=${env.DATABASE_URL} /root/.local/bin/uv run pytest"
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo 'Limpiando recursos...'
                // Borrar el contenedor si se quedó pegado
                sh "docker rm -f ${env.DB_HOST} || true"
                
                // Desconectar el agente de la red y borrar la red
                def containerId = sh(script: "hostname", returnStdout: true).trim()
                sh "docker network disconnect ${env.TEST_NETWORK} ${containerId} || true"
                sh "docker network rm ${env.TEST_NETWORK} || true"
            }
        }
    }
}