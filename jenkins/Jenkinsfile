// jenkins/Jenkinsfile
pipeline {
    agent {
        dockerfile {
            filename 'jenkins/Dockerfile.ci'
            // Persistent volume for UV cache saves minutes of download time
            args '-u root -v /var/run/docker.sock:/var/run/docker.sock -v uv-cache:/root/.cache/uv'
        }
    }

    environment {
        TEST_NETWORK = "todo-net-${BUILD_NUMBER}"
        DB_HOST = "tododbtest-${BUILD_NUMBER}"
        DB_PORT = "5433" 
        APP_PORT = "9000"
        DATABASE_URL = "postgresql://user:password@${DB_HOST}:${env.DB_PORT}/todo_db"
       
        DOCKER_IMAGE = "salcedoj/todo-app-backend"
        DOCKER_TAG = "${BUILD_NUMBER}"
        DOCKER_CREDENTIAL_ID = 'dockerhub-cred'
        
        // Tells uv to use the mounted cache volume
        UV_CACHE_DIR = "/root/.cache/uv"

    }

    stages {
        stage('Setup Environment') {
            steps {
                script {
                    sh "docker network create ${TEST_NETWORK}"
                    def containerId = sh(script: "hostname", returnStdout: true).trim()
                    sh "docker network connect ${TEST_NETWORK} ${containerId}"
                }
            }
        }

        stage('Validation & Testing') {
            parallel {
                stage('Code Quality & Security') {
                    steps {
                        script {
                            echo 'Running Lint & Security analysis...'
                            sh 'uv sync --frozen'
                            sh 'uv run ruff check .'
                            sh 'uv run bandit -r app/'
                        }
                    }
                }

                stage('Integration Tests (Database)') {
                    steps {
                        script {
                            docker.image('postgres:15-alpine').withRun(
                                "--network ${env.TEST_NETWORK} --name ${env.DB_HOST} " +
                                "-e POSTGRES_USER=user -e POSTGRES_PASSWORD=password -e POSTGRES_DB=todo_db " +
                                "-e PGPORT=${env.DB_PORT}" 
                            ) { c ->
                                echo "Waiting for DB on port ${env.DB_PORT}..."
                                // Faster than sleep 20: Checks every second if DB is ready
                                sh "until pg_isready -h ${DB_HOST} -p ${DB_PORT}; do sleep 1; done"
                                
                                sh 'uv sync --frozen'
                                sh "DATABASE_URL=${env.DATABASE_URL} uv run pytest"
                            }
                        }
                    }
                }
            }
        }

        stage('Containerize & Security Scan') {
            steps {
                script {
                    echo "Building and Scanning Image..."
                    sh "docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} -t ${DOCKER_IMAGE}:latest ."
                    sh "trivy image --severity CRITICAL --exit-code 0 ${DOCKER_IMAGE}:${DOCKER_TAG}"
                }
            }
        }

        stage('Publish Image to DockerHub') {
            when {
                expression { 
                    return env.BRANCH_NAME == 'main' || 
                           env.GIT_BRANCH == 'main' || 
                           env.GIT_BRANCH == 'origin/main' || 
                           env.GIT_BRANCH == 'refs/remotes/origin/main'
                }
            }
            steps {
                script {
                    docker.withRegistry('https://index.docker.io/v1/', env.DOCKER_CREDENTIAL_ID) {
                        sh "docker push ${DOCKER_IMAGE}:${DOCKER_TAG}"
                        sh "docker push ${DOCKER_IMAGE}:latest"
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo 'Limpiando recursos...'
                sh "docker rm -f ${env.DB_HOST} || true"
                
                // 2. DESCONECTAR EL AGENTE (Paso crítico)
                // Obtenemos el ID del contenedor actual para soltar la red
                try {
                    def containerId = sh(script: "hostname", returnStdout: true).trim()
                    sh "docker network disconnect -f ${env.TEST_NETWORK} ${containerId} || true"
                    echo "Agente desconectado de la red de pruebas."
                } catch (Exception e) {
                    echo "No se pudo desconectar el agente: ${e.message}"
                }

                // 3. Borrar la red (Ahora sí funcionará sin errores)
                sh "docker network rm ${env.TEST_NETWORK} || true"
            }
        }
    }
}